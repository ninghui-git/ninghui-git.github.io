{"total":15,"pageSize":10,"pageCount":2,"data":[{"title":"简述Js中的原型与原型链","slug":"简述Js中的原型与原型链","date":"2020-07-15T09:29:29.000Z","updated":"2021-03-08T09:43:24.542Z","comments":true,"path":"api/articles/简述Js中的原型与原型链.json","excerpt":"","keywords":null,"cover":"https://howlcn1997.github.io/2020/01/17/%E7%AE%80%E8%BF%B0Js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png","content":"<h2 id=\"1、原型\"><a href=\"#1、原型\" class=\"headerlink\" title=\"1、原型\"></a>1、原型</h2><p> Javascript是基于对象的编程语言，他其中也含有部分封装、继承的概念，而原型概念便是基于继承的。</p>\n<p> 函数的原型类似于面向对象语言中子类的父类，而函数本身类似于子类。函数继承了函数原型中的属性和方法，即函数本身可以调用它原型中的属性和方法。</p>\n<p> 知识点：若有函数Person，则它的函数原型为Person.prototype，函数原型本身是个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person (name) &#123;</span><br><span class=\"line\">  this.name &#x3D; name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.type &#x3D; &#39;human&#39;</span><br><span class=\"line\">Person.prototype.sayName &#x3D; function () &#123;</span><br><span class=\"line\">  console.log(this.name + &#39;说话了&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;此时我们用Person构造函数构造了一个p对象</span><br><span class=\"line\">var p &#x3D; new Person(&#39;小王&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;我们打印p.name</span><br><span class=\"line\">console.log(p.name); &#x2F;&#x2F;结果是&#39;小王&#39;，因为Preson函数中已经预置了name属性并且接受了new对象时传入的&#39;小王&#39;，结果勿容置疑</span><br><span class=\"line\">&#x2F;&#x2F;我们再打印p.type 调用p.sayName()  按常理说Preson构造函数中是不存在type属性和sayName方法，若调用应该会报错</span><br><span class=\"line\">console.log(p.type); &#x2F;&#x2F;结果  human</span><br><span class=\"line\">p.sayName(); &#x2F;&#x2F; 结果  小王说话了</span><br><span class=\"line\">&#x2F;&#x2F;结果和我们预想的不同，这是为什么呢?</span><br><span class=\"line\">&#x2F;&#x2F;因为Person继承了它原型Person.prototype中的信息，当调用p.type时，会优先在Person类中找该属性，若找到了则直接使用，若没找到则在他的原型中找并使用。因为我们设置了Person原型的type属性的，则p可以直接使用</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中涉及到了 构造函数、对象和函数原型，接下来给出三者之间的关系图；</p>\n<h2 id=\"2、构造函数、实例、原型三者之间的关系\"><a href=\"#2、构造函数、实例、原型三者之间的关系\" class=\"headerlink\" title=\"2、构造函数、实例、原型三者之间的关系\"></a>2、构造函数、实例、原型三者之间的关系</h2><p><img src=\"https://howlcn1997.github.io/2020/01/17/%E7%AE%80%E8%BF%B0Js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png\" alt=\"三者关系\"></p>\n<p>由图中我们可以很直观的看到三者之间的关系。</p>\n<p>p对象由Person构造函数构造</p>\n<p>p对象通过__proto__属性访问到Person对象原型</p>\n<p>Person对象原型通过constructor访问Person构造函数</p>\n<p>Person函数通过prototype属性访问到Person原型对象</p>\n<p>注意：对象是通过__proto__属性访问对象原型，函数是通过prototype访问对象原型，但两者访问到的对象原型是同一个</p>\n<p>验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(p.__proto__ &#x3D;&#x3D; Person.prototype); &#x2F;&#x2F;结果为 true</span><br></pre></td></tr></table></figure>\n\n<p>constructor的作用：可以使得对象访问到对应的构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p &#x3D; new Person();</span><br><span class=\"line\">console.log(p.constructor);&#x2F;&#x2F; 打印  function Person()</span><br></pre></td></tr></table></figure>\n\n<p>知道以上的知识之后，我们还要了解，其实Person的原型也有原型，即存在Person.prototype.prototype，并且它是Person.prototype的原型，可以用图来直观了解这其中的关系，这便是一个简单的原型链。</p>\n<h2 id=\"3、原型链\"><a href=\"#3、原型链\" class=\"headerlink\" title=\"3、原型链\"></a>3、原型链</h2><p><img src=\"https://howlcn1997.github.io/2020/01/17/%E7%AE%80%E8%BF%B0Js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"原型链\"></p>\n<h2 id=\"4、原型链中的搜索规则\"><a href=\"#4、原型链中的搜索规则\" class=\"headerlink\" title=\"4、原型链中的搜索规则\"></a>4、原型链中的搜索规则</h2><p>了解了 <strong>构造函数-实例-原型对象</strong> 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。</p>\n<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性</p>\n<ul>\n<li>搜索首先从对象实例本身开始</li>\n<li>如果在实例中找到了具有给定名字的属性，则返回该属性的值</li>\n<li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性</li>\n<li>如果在原型对象中找到了这个属性，则返回该属性的值</li>\n</ul>\n<p>也就是说，在我们调用 <code>p.sayName()</code> 的时候，会先后执行两次搜索：</p>\n<ul>\n<li>首先，解析器会问：“实例 p 有 sayName 属性吗？”答：“没有。</li>\n<li>”然后，它继续搜索，再问：“ p 的原型有 sayName 属性吗？”答：“有。</li>\n<li>”于是，它就读取那个保存在原型对象中的函数。</li>\n</ul>\n<p>而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>\n<p>总结：</p>\n<ul>\n<li>先在自己身上找，找到即返回</li>\n<li>自己身上找不到，则沿着原型链向上查找，找到即返回</li>\n<li>如果一直到原型链的末端还没有找到，则返回 <code>undefined</code></li>\n</ul>\n","text":"1、原型 Javascript是基于对象的编程语言，他其中也含有部分封装、继承的概念，而原型概念便是基于继承的。 函数的原型类似于面向对象语言中子类的父类，而函数本身类似于子类。函数继承了函数原型中的属性和方法，即函数本身可以调用它原型中的属性和方法。 知识点：若有函数Perso","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"Hello React","slug":"Hello React","date":"2020-07-02T05:24:49.000Z","updated":"2021-03-08T09:42:58.156Z","comments":true,"path":"api/articles/Hello React.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>至今一直在使用公司的脚手架或者<code>create-react-app</code>来构建React项目，使用的时间越长，就对于这种<code>理所当然</code>感到疑惑，遂决定利用<code>webpack</code>手动构建一个react项目。</p>\n<h2 id=\"简述webpack\"><a href=\"#简述webpack\" class=\"headerlink\" title=\"简述webpack\"></a>简述webpack</h2><blockquote>\n<p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的*静态模块打包器(module bundler)<em>。当 webpack 处理应用程序时，它会递归地构建一个</em>依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em></p>\n</blockquote>\n<p>核心概念</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry &#x2F;&#x2F; webpack进行静态分析的入口文件</span><br><span class=\"line\"></span><br><span class=\"line\">output &#x2F;&#x2F; webpack打包后输出的目标文件</span><br><span class=\"line\"></span><br><span class=\"line\">loader &#x2F;&#x2F; 静态分析时对不同文件使用不同的loader进行处理</span><br><span class=\"line\"></span><br><span class=\"line\">plugins &#x2F;&#x2F; 从分析的开始到结束，以完成loader职能之外的工作</span><br></pre></td></tr></table></figure>\n\n<p>简述整个过程：由入口文件开始分析，根据其依赖模块顺藤摸瓜找到不同的文件，并对不同的文件进行<code>loader</code>处理，此期间<code>plugin</code>做相应工作（如：代码压缩，打包优化，修改环境变量等），打包结果输出到<code>output</code>指定的目标文件。</p>\n<h2 id=\"Todo\"><a href=\"#Todo\" class=\"headerlink\" title=\"Todo\"></a>Todo</h2><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 创建文件夹</span><br><span class=\"line\">mkdir hello-react</span><br><span class=\"line\">cd hello-react</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 初识化npm项目   -y 使用默认package.json</span><br><span class=\"line\">npm init -y</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构建项目目录框架\"><a href=\"#构建项目目录框架\" class=\"headerlink\" title=\"构建项目目录框架\"></a>构建项目目录框架</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── build                  开发打包资源</span><br><span class=\"line\">├── dist                   线上打包资源</span><br><span class=\"line\">├── public                 公共资源</span><br><span class=\"line\">├── src                    源码目录</span><br><span class=\"line\">|    └──index.js\t\t  入口文件</span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; &#x2F;src&#x2F;index.js</span><br><span class=\"line\">console.log(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装webpack\"><a href=\"#安装webpack\" class=\"headerlink\" title=\"安装webpack\"></a>安装webpack</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; -D 是--save-dev的简写   -S 是--save的简写</span><br><span class=\"line\">npm i webpack webpack-cli -D</span><br></pre></td></tr></table></figure>\n\n<p>此时简单运行一下，终端输入<code>webpack</code>，此时dist中会生成一个<code>main.js</code>文件。</p>\n<p>这是因为<code>webpack</code>会有默认的打包配置（入口文件为<code>/src/index.js</code>，输入文件为<code>/dist/main.js</code>）。</p>\n<p>运行一下<code>main.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node .&#x2F;dist&#x2F;main.js</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<p>当然你可以使用自己的<code>webpack</code>配置以覆盖默认配置</p>\n<h2 id=\"webpack-config-js\"><a href=\"#webpack-config-js\" class=\"headerlink\" title=\"webpack.config.js\"></a>webpack.config.js</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>在项目根目录下创建<code>webpack.config.js</code>，<code>webpack</code>默认会在项目根目录下寻找<code>webpack.config.js</code>以覆盖默认配置，当然，你也可以指定任意路径，只需要</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --config [配置文件的目标路径]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; node中的核心模块，用于文件路径处理</span><br><span class=\"line\">const path &#x3D; require(&quot;path&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    entry: path.join(__dirname,&#39;.&#x2F;src&#x2F;index.js&#39;),</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: path.join(__dirname, &quot;.&#x2F;build&quot;),</span><br><span class=\"line\">        filename:&quot;main.js&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F; 定义当前打包环境</span><br><span class=\"line\">    mode: &quot;development&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"写React\"><a href=\"#写React\" class=\"headerlink\" title=\"写React\"></a>写React</h2><p>之前只是简单的执行了打印语句，并没有<code>dom</code>操作，接下来开始使用<code>React</code>，写我们最爱的<code>JSX</code>。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i react react-dom -S</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"支持\"><a href=\"#支持\" class=\"headerlink\" title=\"支持\"></a>支持</h3><p>webpack本身是不识别JSX的，这里需要借助相应loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i babel-loader @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;preset-react   -S</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"webpack配置\"><a href=\"#webpack配置\" class=\"headerlink\" title=\"webpack配置\"></a>webpack配置</h4><blockquote>\n<p>在顺藤摸瓜的过程中若碰到 <code>.js</code> <code>.jsx</code>则启用<code>babel-loader</code></p>\n<p>而babel就会去查询相应babel配置【<code>.babelrc</code>】做出相应<code>transfrom</code></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; webpack.config.js</span><br><span class=\"line\">module:&#123;</span><br><span class=\"line\">    rules: [&#123;</span><br><span class=\"line\">        test: &#x2F;\\.(js|jsx)$&#x2F;,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">            loader: &quot;babel-loader&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"babel配置\"><a href=\"#babel配置\" class=\"headerlink\" title=\"babel配置\"></a>babel配置</h4><p>在项目根目录中新建babel的配置文件<code>.babelrc</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; .babelrc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;: [</span><br><span class=\"line\">        [</span><br><span class=\"line\">            &quot;@babel&#x2F;preset-env&quot;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;useBuiltIns&quot;: &quot;usage&quot; &#x2F;&#x2F;按需注⼊polyfill</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">        &quot;@babel&#x2F;preset-react&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于<code>@babel/preset-env</code>的配置详情，请见<a href=\"https://zhuanlan.zhihu.com/p/84799735\">Babel7 中 @babel/preset-env 的使用</a> 和 <a href=\"https://www.babeljs.cn/docs/babel-preset-env\">babeljs.cn</a></p>\n<h3 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; &#x2F;src&#x2F;index.js</span><br><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import ReactDOM from &quot;react-dom&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">function App() &#123;</span><br><span class=\"line\">    return &lt;div&gt;Hello React&lt;&#x2F;div&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTML宿主\"><a href=\"#HTML宿主\" class=\"headerlink\" title=\"HTML宿主\"></a>HTML宿主</h3><p>目前我们将打包后的代码输出到 <code>/build/main.js</code>，那我们就在<code>/build</code>下新建<code>index.html</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">        &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;Hello React&lt;&#x2F;title&gt;</span><br><span class=\"line\">    &lt;&#x2F;head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">        &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>完成后，用浏览器打开<code>index.html</code></p>\n<p>至此初步完成了<code>webpack搭建React项目</code>的任务</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇文章用到的npm包：</p>\n<ol>\n<li>webpack</li>\n<li>webpack-cli</li>\n<li>babel-loader</li>\n<li>@babel/core</li>\n<li>@babel/preset-env</li>\n<li>@babel/preset-react</li>\n<li>react</li>\n<li>react-dom</li>\n</ol>\n","text":"前言至今一直在使用公司的脚手架或者create-react-app来构建React项目，使用的时间越长，就对于这种理所当然感到疑惑，遂决定利用webpack手动构建一个react项目。简述webpack本质上，webpack 是一个现代 JavaScript 应用程序的*静态模块","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"前端性能优化及兼容问题","slug":"前端性能优化及兼容问题","date":"2020-06-15T04:20:32.000Z","updated":"2021-03-08T09:43:20.193Z","comments":true,"path":"api/articles/前端性能优化及兼容问题.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h2><h3 id=\"减少http请求数量和体积\"><a href=\"#减少http请求数量和体积\" class=\"headerlink\" title=\"减少http请求数量和体积\"></a>减少http请求数量和体积</h3><p> -压缩 css、js 文件<br>-合并 js、css 文件，减少 http 请求<br>-使用CSS Sprites图，合并多个CSS图片，合理使用图片压缩<br>-合理使用http缓存，减少http请求<br>-使用外部的css和js以减少服务器的压力</p>\n<h3 id=\"css和script的位置\"><a href=\"#css和script的位置\" class=\"headerlink\" title=\"css和script的位置\"></a>css和script的位置</h3><p> 把 css 样式引入放在<code>&lt;head&gt;</code>标签中，把 <code>&lt;script&gt;</code>资源引入放在<code>&lt;/body&gt;</code>闭合之前。<br>外链脚本在加载时却常常阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。所以说尽可能的将脚本往后挪，减少对并发下载的影响</p>\n<h3 id=\"DOM操作优化\"><a href=\"#DOM操作优化\" class=\"headerlink\" title=\"DOM操作优化\"></a>DOM操作优化</h3><p> -要避免在document上直接进行频繁的DOM操作(用innerHTML代替DOM操作)，缓存DOM节点查找的结果<br>-使用classname代替大量的内联样式修改<br>-对于复杂的UI元素，设置position为absolute或fixed<br>-在js动画和css动画之间尽量使用css动画<br>-适当使用canvas<br>-使用事件代理<br>-避免使用eval或Function，每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码，这是很消耗资源的操作<br>-避免大量的字符串拼接，可以使用数组的join方法</p>\n<h3 id=\"CSS选择符优化\"><a href=\"#CSS选择符优化\" class=\"headerlink\" title=\"CSS选择符优化\"></a>CSS选择符优化</h3><p> -避免使用通配符选择器，避免使用后代选择器<br>-选择器匹配是从右向左匹配的，选择器语句链越短，浏览器的匹配速度越快<br>-避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作<br>-搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）。在写样式时，避免触发重新布局的可能<br>-减少使用昂贵的属性，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。box-shadow/border-radius/filter/透明度/:nth-child等<br>-不要使用@import<br>-尽量减少css表达式的使用 background-color: expression((new Date()).getHours()%2?”#FFFFFF”: “#000000” );</p>\n<h2 id=\"HTML常见兼容性问题\"><a href=\"#HTML常见兼容性问题\" class=\"headerlink\" title=\"HTML常见兼容性问题\"></a>HTML常见兼容性问题</h2><h3 id=\"IE不支持h5新标签和c3媒体查询的问题\"><a href=\"#IE不支持h5新标签和c3媒体查询的问题\" class=\"headerlink\" title=\"IE不支持h5新标签和c3媒体查询的问题\"></a>IE不支持h5新标签和c3媒体查询的问题</h3><p>引入html5shiv.js在IE浏览器下创建h5标签<br>引入respond.js让IE浏览器支持C3的媒体查询</p>\n<h3 id=\"js代码兼容性问题\"><a href=\"#js代码兼容性问题\" class=\"headerlink\" title=\"js代码兼容性问题\"></a>js代码兼容性问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据兼容需求选择技术框架&#x2F;库(jquery)</span><br><span class=\"line\"></span><br><span class=\"line\">var ev &#x3D; ev || window.event</span><br><span class=\"line\">document.documentElement.clientWidth || document.body.clientWidth</span><br><span class=\"line\">var target &#x3D; ev.srcElement||ev.target</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"css兼容性问题\"><a href=\"#css兼容性问题\" class=\"headerlink\" title=\"css兼容性问题\"></a>css兼容性问题</h3><p>A.使用Reset CSS或Normalize.css做样式的重置<br>B.使用autoprefixer添加浏览器前缀<br>C.使用条件注释针对不同的浏览器引入单独的样式表<br>D.使用已经处理好兼容问题的库，比如BootStrap<br>E.渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验<br>F.优雅降级 (graceful degradation): Web站点在所有新式浏览器中都能正常工作，然后再针对低版本浏览器进行兼容。<br>G.使用CSS hack技术做样式兼容</p>\n<h3 id=\"常见的兼容性问题\"><a href=\"#常见的兼容性问题\" class=\"headerlink\" title=\"常见的兼容性问题\"></a>常见的兼容性问题</h3><p>display:inline-block（IE7及以下不支持）<br>需要对低版本IE特殊处理：{display:inline-block;display:inline;zoom:1;}</p>\n<p>display:inline-block 什么时候会显示间隙？怎样消除间隙？<br>父元素font-size设置成0，子元素重新设置font-size</p>\n<p>display:inline-block滥用容易出现布局方面的问题，尤其在左中右、左右等布局方面的问题尤为突出。因此如果是左右布局的话，尽量都用浮动来代替</p>\n<p>z-index在IE7及以下版本的话，有时会发现不是谁z-index设置的越高谁就显示在最上面。碰到这种问题需要设置父元素有相对定位属性元素的z-index。先比较父元素的z-index再比较子元素的</p>\n<p>IE6双边距：IE6中，元素向左浮动并且设置了左侧的外边距出现了这样的双边距bug。同理，元素向右浮动并且设置右边距也会出现同样的情况。同一行如果有多个浮动元素，第一个浮动元素会出现这个双边距bug，其它的浮动元素则不会。只需要给浮动元素加上display:inline;这样的CSS属性就可以了。</p>\n<p>margin-top，margin-bottom的bug<br>父元素的第一个子元素设置了margin-top,会作用于父元素（值为父元素的margin-top与该margin-top两者中的最大值)，而子元素和父元素的边距则没有发生变化。</p>\n<p>超链接访问之后hover样式不出现了，被点击后也不具有active和hover样式。<br>方法：按照顺序写 ：a:link{ } a:visited{ } a:hover{ } a:active{ }</p>\n<p>IE没有办法定义1像素左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08;line-height:1px）</p>\n<p>IE5-8不支持opacity<br>方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.opacity&#123;</span><br><span class=\"line\">    opacity:0.4,</span><br><span class=\"line\">    filter:alpha(opacity&#x3D;60);</span><br><span class=\"line\">    -ms-filter:&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity&#x3D;60)&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>IE6不支持PNG透明管背景色，IE6下使用gif图片,png24的图片在ie6浏览器上显示背景色，做成png8的</p>\n<p>IE下even对象只有x,y属性，但是没有pagex和pagey属性，火狐只有pagex pagey属性。</p>\n<p>谷歌下默认会将小于12px的文本设置按照12px显示，可是通过加入-webkit-text-size-adjust:none;</p>\n<h2 id=\"附录：重排和重绘的操作\"><a href=\"#附录：重排和重绘的操作\" class=\"headerlink\" title=\"附录：重排和重绘的操作\"></a>附录：重排和重绘的操作</h2><h3 id=\"重排的操作\"><a href=\"#重排的操作\" class=\"headerlink\" title=\"重排的操作\"></a>重排的操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width\theight\tpadding\tmargin</span><br><span class=\"line\">display\tborder-width\tborder\ttop</span><br><span class=\"line\">position\tfont-size\tfloat\ttext-align</span><br><span class=\"line\">overflow-y\tfont-weight\toverflow\tleft</span><br><span class=\"line\">font-family\tline-height\tvertical-align\tright</span><br><span class=\"line\">clear\twhite-space\tbottom\tmin-height</span><br><span class=\"line\">offsetTop  offsetLeft  offsetWidth   offsetHeight</span><br><span class=\"line\">scrollTop   scrollLeft  scrollWidth   scrollHeight</span><br><span class=\"line\">clientTop   clientLeft   clientWidth  clientHeight </span><br><span class=\"line\">getComputedStyle()    (currentStyle in IE)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重绘的操作\"><a href=\"#重绘的操作\" class=\"headerlink\" title=\"重绘的操作\"></a>重绘的操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tcolor\tborder-style\tvisibility\tbackground</span><br><span class=\"line\">text-decoration\tbackground-image\tbackground-position\tbackground-repeat</span><br><span class=\"line\">outline-color\toutline\toutline-style\tborder-radius</span><br><span class=\"line\">outline-width\tbox-shadow\tbackground-size</span><br></pre></td></tr></table></figure>","text":"前端性能优化减少http请求数量和体积 -压缩 css、js 文件<br>-合并 js、css 文件，减少 http 请求<br>-使用CSS Sprites图，合并多个CSS图片，合理使用图片压缩<br>-合理使用http缓存，减少http请求<br>-使用外部的css和js以","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"Vuex的详解","slug":"Vuex的详解","date":"2020-06-08T09:17:58.000Z","updated":"2021-03-08T09:43:13.636Z","comments":true,"path":"api/articles/Vuex的详解.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"什么情况下应该使用-Vuex？\"><a href=\"#什么情况下应该使用-Vuex？\" class=\"headerlink\" title=\"什么情况下应该使用 Vuex？\"></a>什么情况下应该使用 Vuex？</h1><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p>\n<p>如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的store模式就足够了。但是，如果需要构建一个中大型单页应用，就要考虑如何更好地在组件外部管理状态，Vuex 是不错的选择。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>在 Vue 的单页面应用中使用，需要使用<code>Vue.use(Vuex)</code>调用插件。将其注入到Vue根实例中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vuex from &#39;vuex&#39;</span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    doneTodos: (state, getters) &#x3D;&gt; &#123;</span><br><span class=\"line\">      return state.todos.filter(todo &#x3D;&gt; todo.done)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state, payload) &#123;</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123;</span><br><span class=\"line\">    addCount(context) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 可以包含异步操作</span><br><span class=\"line\">      &#x2F;&#x2F; context 是一个与 store 实例具有相同方法和属性的 context 对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F; 注入到根实例</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#app&#39;,</span><br><span class=\"line\">  &#x2F;&#x2F; 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br><span class=\"line\">  store,</span><br><span class=\"line\">  template: &#39;&lt;App&#x2F;&gt;&#39;,</span><br><span class=\"line\">  components: &#123; App &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后改变状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.commit(&#39;increment&#39;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"核心\"><a href=\"#核心\" class=\"headerlink\" title=\"核心\"></a>核心</h1><blockquote>\n<p>State，Getter，Mutation，Action，Module</p>\n</blockquote>\n<p><strong>Vuex 主要有四部分：</strong></p>\n<ol>\n<li>state：包含了<code>store</code>中存储的各个状态。</li>\n<li>getter: 类似于 Vue 中的计算属性，根据其他 getter 或 state 计算返回值。</li>\n<li>mutation: 一组方法，是改变<code>store</code>中状态的执行者，<strong>只能是同步操作</strong>。</li>\n<li>action: 一组方法，其中可以<strong>包含异步操作</strong>。</li>\n</ol>\n<h2 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h2><p>Vuex 使用 <code>state</code> 来存储应用中需要共享的状态。为了能让 Vue 组件在 <code>state</code>更改后也随着更改，需要基于<code>state</code> 创建计算属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 创建一个 Counter 组件</span><br><span class=\"line\">const Counter &#x3D; &#123;</span><br><span class=\"line\">  template: &#96;&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;&#96;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      return this.$store.state.count  &#x2F;&#x2F; count 为某个状态</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h2><p>类似于 Vue 中的 计算属性（可以认为是 store 的计算属性），getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<p>Getter 方法接受<code>state</code>作为其第一个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    todos: [</span><br><span class=\"line\">      &#123; id: 1, text: &#39;...&#39;, done: true &#125;,</span><br><span class=\"line\">      &#123; id: 2, text: &#39;...&#39;, done: false &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    doneTodos: state &#x3D;&gt; &#123;</span><br><span class=\"line\">      return state.todos.filter(todo &#x3D;&gt; todo.done)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"通过属性访问\"><a href=\"#通过属性访问\" class=\"headerlink\" title=\"通过属性访问\"></a>通过属性访问</h3><p>Getter 会暴露为 <code>store.getters</code> 对象，可以以属性的形式访问这些值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.getters.doneTodos &#x2F;&#x2F; -&gt; [&#123; id: 1, text: &#39;...&#39;, done: true &#125;]</span><br></pre></td></tr></table></figure>\n\n<p>Getter 方法也接受 <code>state</code>和其他<code>getters</code>作为前两个参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">  doneTodosCount: (state, getters) &#x3D;&gt; &#123;</span><br><span class=\"line\">    return getters.doneTodos.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.getters.doneTodosCount &#x2F;&#x2F; -&gt; 1</span><br></pre></td></tr></table></figure>\n\n<p>我们可以很容易地在任何组件中使用它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  doneTodosCount () &#123;</span><br><span class=\"line\">    return this.$store.getters.doneTodosCount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong> getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>\n<h3 id=\"通过方法访问\"><a href=\"#通过方法访问\" class=\"headerlink\" title=\"通过方法访问\"></a>通过方法访问</h3><p>也可以通过让 getter 返回一个函数，来实现给 getter 传参。在对 store 里的数组进行查询时非常有用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">  getTodoById: (state) &#x3D;&gt; (id) &#x3D;&gt; &#123;</span><br><span class=\"line\">    return state.todos.find(todo &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.getters.getTodoById(2) &#x2F;&#x2F; -&gt; &#123; id: 2, text: &#39;...&#39;, done: false &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong> getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>\n<h2 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h2><blockquote>\n<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。也就是说，前面两个都是状态值本身，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; mutations</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>才是改变状态的执行者。</p>\n<p><strong>注意：mutations只能是同步地更改状态。</strong></p>\n</blockquote>\n<p>Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 变更状态</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>调用 <code>store.commit</code> 方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.commit(&#39;increment&#39;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"提交载荷（Payload）\"><a href=\"#提交载荷（Payload）\" class=\"headerlink\" title=\"提交载荷（Payload）\"></a>提交载荷（Payload）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; ...</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, n) &#123;</span><br><span class=\"line\">    state.count +&#x3D; n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.commit(&#39;increment&#39;, 10)</span><br></pre></td></tr></table></figure>\n\n<p>其中，第一个参数是<code>state</code>，后面的参数是向 <code>store.commit</code> 传入的额外的参数，即 mutation 的 <strong>载荷（payload）</strong>。</p>\n<p><code>store.commit</code>方法的第一个参数是要发起的<code>mutation</code>类型名称，后面的参数均当做额外数据传入<code>mutation</code>定义的方法中。</p>\n<p><strong>规范的发起mutation的方式如下：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 以载荷形式</span><br><span class=\"line\">store.commit(&#39;increment&#39;，&#123;</span><br><span class=\"line\">  amount: 10   &#x2F;&#x2F;这是额外的参数</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 或者使用对象风格的提交方式</span><br><span class=\"line\">store.commit(&#123;</span><br><span class=\"line\">  type: &#39;increment&#39;,</span><br><span class=\"line\">  amount: 10   &#x2F;&#x2F;这是额外的参数</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>额外的参数会封装进一个对象，作为第二个参数传入<code>mutation</code>定义的方法中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  increment (state, payload) &#123;</span><br><span class=\"line\">    state.count +&#x3D; payload.amount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h2><p>想要<strong>异步地更改状态</strong>，就需要使用<code>action</code>。<code>action</code>并不直接改变<code>state</code>，而是发起<code>mutation</code>。</p>\n<p>注册一个简单的 action：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123;</span><br><span class=\"line\">    increment (context) &#123;</span><br><span class=\"line\">      context.commit(&#39;increment&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。当我们在之后介绍到 <code>Modules</code> 时，你就知道 context 对象为什么不是 store 实例本身了。</p>\n<p>实践中，我们会经常用到 ES2015 的 <a href=\"https://github.com/lukehoban/es6features#destructuring\">参数解构</a> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  increment (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    commit(&#39;increment&#39;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在action内部执行<strong>异步</strong>操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">      commit(&#39;increment&#39;)</span><br><span class=\"line\">    &#125;, 1000)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发起<code>action</code>的方法形式和发起<code>mutation</code>一样，只是换了个名字<code>dispatch</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 以对象形式分发Action</span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: &#39;incrementAsync&#39;,</span><br><span class=\"line\">  amount: 10</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Actions 支持同样的载荷方式和对象方式进行分发</p>\n</blockquote>\n<h3 id=\"Action处理异步的正确使用方式\"><a href=\"#Action处理异步的正确使用方式\" class=\"headerlink\" title=\"Action处理异步的正确使用方式\"></a>Action处理异步的正确使用方式</h3><p>想要使用<code>action</code>处理异步工作很简单，只需要将异步操作放到<code>action</code>中执行（如上面代码中的<code>setTimeout</code>）。</p>\n<p>要想在异步操作完成后继续进行相应的流程操作，有两种方式:</p>\n<ol>\n<li><p><code>store.dispatch</code>返回相应<code>action</code>的执行结果，而action的处理函数返回的就是Promise，所以<code>store.dispatch</code>仍然返回一个Promise。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">        commit(&#39;someMutation&#39;)</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">      &#125;, 1000)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在可以写成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&#39;actionA&#39;).then(() &#x3D;&gt; &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在另外一个 action 中也可以：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    return dispatch(&#39;actionA&#39;).then(() &#x3D;&gt; &#123;</span><br><span class=\"line\">      commit(&#39;someOtherMutation&#39;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>利用<code>async/await</code> 进行组合action。代码更加简洁。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><span class=\"line\"></span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  async actionA (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    commit(&#39;gotData&#39;, await getData())</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  async actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class=\"line\">    await dispatch(&#39;actionA&#39;) &#x2F;&#x2F; 等待 actionA 完成</span><br><span class=\"line\">    commit(&#39;gotOtherData&#39;, await getOtherData())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"Action与Mutation的区别\"><a href=\"#Action与Mutation的区别\" class=\"headerlink\" title=\"Action与Mutation的区别\"></a>Action与Mutation的区别</h3><p>Action 类似于 mutation，不同在于：</p>\n<ul>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作，而Mutation只能且必须是同步操作。</li>\n</ul>\n<h2 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h2><blockquote>\n<p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>\n<p>这时我们可以将 store 分割为<strong>模块（module）</strong>，每个模块拥有自己的 <code>state</code> 、 <code>getters</code> 、<code>mutations</code> 、<code>actions</code> 、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>\n</blockquote>\n<p>代码示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA &#x3D; &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB &#x3D; &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store &#x3D; new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a &#x2F;&#x2F; -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b &#x2F;&#x2F; -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌套子模块\"><a href=\"#嵌套子模块\" class=\"headerlink\" title=\"嵌套子模块\"></a>嵌套子模块</h3><p>首先创建子模块的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; products.js</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; initial state</span><br><span class=\"line\">const state &#x3D; &#123;</span><br><span class=\"line\">  added: [],</span><br><span class=\"line\">  checkoutStatus: null</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; getters</span><br><span class=\"line\">const getters &#x3D; &#123;</span><br><span class=\"line\">  checkoutStatus: state &#x3D;&gt; state.checkoutStatus</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; actions</span><br><span class=\"line\">const actions &#x3D; &#123;</span><br><span class=\"line\">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; mutations</span><br><span class=\"line\">const mutations &#x3D; &#123;</span><br><span class=\"line\">  mutation1 (state, &#123; id &#125;) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  state,</span><br><span class=\"line\">  getters,</span><br><span class=\"line\">  actions,</span><br><span class=\"line\">  mutations</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在总模块中引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vuex from &#39;vuex&#39;</span><br><span class=\"line\">import products from &#39;.&#x2F;modules&#x2F;products&#39; &#x2F;&#x2F;引入子模块</span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"></span><br><span class=\"line\">export default new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    products   &#x2F;&#x2F; 添加进模块中</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"各个模块与-Vue-组件结合\"><a href=\"#各个模块与-Vue-组件结合\" class=\"headerlink\" title=\"各个模块与 Vue 组件结合\"></a>各个模块与 Vue 组件结合</h1><p>将<code>state</code>和<code>getter</code>结合进组件需要使用<strong>计算属性</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      return this.$store.state.count </span><br><span class=\"line\">      &#x2F;&#x2F; 或者 return this.$store.getter.count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>将<code>mutation</code>和<code>action</code>结合进组件需要在<code>methods</code>中调用<code>this.$store.commit()</code>或者<code>this.$store.commit()</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    changeDate () &#123;</span><br><span class=\"line\">        this.$store.commit(&#39;change&#39;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    changeDateAsync () &#123;</span><br><span class=\"line\">        this.$store.commit(&#39;changeAsync&#39;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了简便起见，Vuex 提供了四个辅助函数方法用来方便的将这些功能结合进组件。</p>\n<ol>\n<li><code>mapState</code></li>\n<li><code>mapGetters</code></li>\n<li><code>mapMutations</code></li>\n<li><code>mapActions</code></li>\n</ol>\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapState, mapGetters, mapMutations, mapActions &#125; from &#39;vuex&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">    computed: &#123;</span><br><span class=\"line\">      localComputed () &#123; &#x2F;* ... *&#x2F; &#125;,</span><br><span class=\"line\">        &#x2F;&#x2F; 使用对象展开运算符将此对象混入外部对象中</span><br><span class=\"line\">      ...mapState(&#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 为了能够使用 &#96;this&#96; 获取局部状态，必须使用常规函数</span><br><span class=\"line\">        count(state) &#123;</span><br><span class=\"line\">          return state.count + this.localCount</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;),</span><br><span class=\"line\">      ...mapGetters(&#123;</span><br><span class=\"line\">        getterCount(state, getters) &#123;</span><br><span class=\"line\">          return state.count + this.localCount</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">      ...mapMutations(&#123;</span><br><span class=\"line\">          &#x2F;&#x2F; 如果想将一个属性另取一个名字，使用以下形式。注意这是写在对象中</span><br><span class=\"line\">           add: &#39;increment&#39; &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为&#96;this.$store.commit(&#39;increment&#39;)&#96;</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">      ...mapActions(&#123;</span><br><span class=\"line\">          add: &#39;increment&#39; &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 &#96;this.$store.dispatch(&#39;increment&#39;)&#96;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果结合进组件之后不想改变名字，可以直接使用<strong>数组</strong>的方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">      &#39;increment&#39;, &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 &#96;this.$store.dispatch(&#39;increment&#39;)&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#x2F;&#x2F; &#96;mapActions&#96; 也支持载荷：</span><br><span class=\"line\">      &#39;incrementBy&#39; &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 &#96;this.$store.dispatch(&#39;incrementBy&#39;, amount)&#96;</span><br><span class=\"line\">    ]),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>为何使用展开运算符：</strong><code>mapState</code> 等四个函数返回的都是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 <code>computed</code> 属性。但是有了对象展开运算符，我们就可以进行简化写法。</p>\n</blockquote>\n","text":"什么情况下应该使用 Vuex？Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的store模式就足够了。但是，如果需要构建一个中大型单页应用，就要考虑如何更好地在","link":"","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"前端Http协议缓存","slug":"前端Http协议缓存","date":"2020-05-21T07:15:51.000Z","updated":"2021-03-08T09:14:34.680Z","comments":true,"path":"api/articles/前端Http协议缓存.json","excerpt":"","keywords":null,"cover":"https://jasonms0.github.io/2020/02/23/%E5%89%8D%E7%AB%AFHttp%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%AD%98/aaa.png","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>用户获取网络资源，需要通过非常长的网络去服务器上请求资源,另外服务端为了应对大量的用户请求而不断的提升硬件性能与带宽。这对用户与服务端都非常的不友好。而缓存就是为了解决用户请求速度与释放服务器压力而生的。</p>\n<h2 id=\"缓存的判断规则\"><a href=\"#缓存的判断规则\" class=\"headerlink\" title=\"缓存的判断规则\"></a>缓存的判断规则</h2><h3 id=\"过期机制\"><a href=\"#过期机制\" class=\"headerlink\" title=\"过期机制\"></a>过期机制</h3><p>过期机制就是浏览器根据缓存的有效期进行判断，如果在有效期内就使用缓存，否则就抛弃这个缓存。</p>\n<p>一个缓存副本必须满足以下条件，浏览器会认为它是有效的，足够新的：</p>\n<p>　　　　1. 含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内；</p>\n<p>　　　　2. 浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度；</p>\n<h3 id=\"验证机制\"><a href=\"#验证机制\" class=\"headerlink\" title=\"验证机制\"></a>验证机制</h3><p>浏览器带上本地缓存副本的验证信息提交给服务器(Last-Modified,ETag)，由服务器决定是否采用这个缓存。</p>\n<p>客户端请求的时候带上Last-Modified，服务器进行验证返回If-Modified-Since来确定资源是否是有效缓存。<br>另外在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。</p>\n<h2 id=\"缓存来源\"><a href=\"#缓存来源\" class=\"headerlink\" title=\"缓存来源\"></a>缓存来源</h2><h4 id=\"from-disk-cache\"><a href=\"#from-disk-cache\" class=\"headerlink\" title=\"from disk cache\"></a>from disk cache</h4><p>此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache。</p>\n<h4 id=\"from-memory-cache\"><a href=\"#from-memory-cache\" class=\"headerlink\" title=\"from memory cache\"></a>from memory cache</h4><p>字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况。</p>\n<h4 id=\"请求来源\"><a href=\"#请求来源\" class=\"headerlink\" title=\"请求来源\"></a>请求来源</h4><p>当http状态为200是实实在在从浏览器获取的资源，当http状态为304时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的。</p>\n<h2 id=\"缓存类型\"><a href=\"#缓存类型\" class=\"headerlink\" title=\"缓存类型\"></a>缓存类型</h2><h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&#39;Expires&#39;,&#39;Mon Jan 01 2018 08:00:00 GMT&#39;) &#x2F;&#x2F;必须用格林威治时间格式</span><br></pre></td></tr></table></figure>\n\n<p>服务器发送给客户端一个UTC时间(如 expires: Mon Jan 01 2018 08:00:00 GMT)，浏览器接收到了这个头，就会为这个资源标记一个过期时间，在下次的请求时候判断未过期会直接使用这个资源缓存。来源会标记为<code>from disk cache</code>。</p>\n<p>浏览器在取到这个缓存资源的时候，会用客户机的时间与之<code>对比</code>，如果还在<code>有效期</code>内，则直接使用这个缓存，不进行<code>网络请求</code>。否则会进入其他缓存依据判断。</p>\n<p>而这个机制会有一个问题，就是，缓存资源是否过期依赖客户机时间。客户机可以通过<code>修改</code>当前时间来使这个缓存资源<code>失效</code>。</p>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&#39;Cache-Control&#39;,&#39;public,max-age&#x3D;100&#39;)</span><br></pre></td></tr></table></figure>\n\n<p>HTTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p>\n<h5 id=\"max-age\"><a href=\"#max-age\" class=\"headerlink\" title=\"max-age\"></a>max-age</h5><p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age&#x3D;100</span><br></pre></td></tr></table></figure>\n\n<p>这个示例表示，这个缓存资源在本次请求后的100秒之后都有效。浏览器会直接返回<code>from disk cache</code>，不进行网络资源请求。</p>\n<h5 id=\"no-cache-和-no-store\"><a href=\"#no-cache-和-no-store\" class=\"headerlink\" title=\"no-cache 和 no-store\"></a>no-cache 和 no-store</h5><p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: no-cache      Cache-Control: no-store</span><br></pre></td></tr></table></figure>\n\n<p>这两个参数都表示每一次请求，都需要发送一个网络请求。<br>他们之间的区别是<br><strong>no-cache：</strong> 并不是真的不缓存数据，他只是每次都确认资源是否过期，利用ETag令牌一定程度上减少传输流量<br><strong>no-store：</strong> 要求客户端每次都重新请求资源，不做任何缓存处理。</p>\n<h5 id=\"public-和-private\"><a href=\"#public-和-private\" class=\"headerlink\" title=\"public 和 private\"></a>public 和 private</h5><p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: public     Cache-Control: private</span><br></pre></td></tr></table></figure>\n\n<p><strong>public：</strong> 是一种默认的策略，表示当前缓存是开放的，任何请求想用的中间环节都可以对其进行缓存。<br><strong>private：</strong> 则表示当前相应是针对单个用户的，不建议对其进行缓存。</p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><h4 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified,If-Modified-Since\"></a>Last-Modified,If-Modified-Since</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&#39;Last-Modified&#39;,&#39;Fri,22 Jul 2016 08:00:00 GMT&#39;)</span><br></pre></td></tr></table></figure>\n\n<p>当客户端访问资源时，服务器会将资源<strong>最后修改时间</strong>通过 <code>Last-Modified</code> 标识由服务器发往客户端，客户端记录修改时间，再次请求本地存在的缓存资源时，客户端会通过 <code>If-Modified-Since: Last-Modified-value</code> 将先前服务器端发过来的最后修改时间发送回去，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则重新响应新的页面并回传新的Last-Modified，如果是最新的，则返回<code>304</code>告诉客户端其本地缓存资源是最新的。</p>\n<p><strong>缺陷:</strong></p>\n<p>a、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。</p>\n<p>b、以时刻作为标识，无法识别一秒内进行多次修改的情况。</p>\n<p>c、某些服务器不能精确的得到文件的最后修改时间。</p>\n<h4 id=\"ETag\"><a href=\"#ETag\" class=\"headerlink\" title=\"ETag\"></a>ETag</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&#39;ETag&#39;,&#39;3fd729c07839068ebb6f7f4374981d9f&#39;) &#x2F;&#x2F;一般可用MD5</span><br></pre></td></tr></table></figure>\n\n<p>服务器在响应时，回传一个唯一标志符（比如md5），服务器在把页面响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端</p>\n<p>客户端会保留ETag字段，在下次请求时，通过在请求中添加if-none-match:ETag-value 给服务器，与服务器的ETag字段进行匹配，如果匹配上，则直接回送304 和响应报头即可。反之，则重新发送资源数据并回传新的ETag字段 。</p>\n<h2 id=\"浏览器缓存判断流程\"><a href=\"#浏览器缓存判断流程\" class=\"headerlink\" title=\"浏览器缓存判断流程\"></a>浏览器缓存判断流程</h2><p><a href=\"https://jasonms0.github.io/2020/02/23/%E5%89%8D%E7%AB%AFHttp%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%AD%98/aaa.png\"><img src=\"https://jasonms0.github.io/2020/02/23/%E5%89%8D%E7%AB%AFHttp%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%AD%98/aaa.png\" alt=\"aaa\"></a></p>\n<p><a href=\"https://jasonms0.github.io/2020/02/17/Vuex%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/\">Vuex使用详解</a></p>\n","text":"简介用户获取网络资源，需要通过非常长的网络去服务器上请求资源,另外服务端为了应对大量的用户请求而不断的提升硬件性能与带宽。这对用户与服务端都非常的不友好。而缓存就是为了解决用户请求速度与释放服务器压力而生的。缓存的判断规则过期机制过期机制就是浏览器根据缓存的有效期进行判断，如果在","link":"","raw":null,"photos":[],"categories":[],"tags":[]}]}