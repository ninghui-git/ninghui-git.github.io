{"title":"简述Js中的原型与原型链","slug":"简述Js中的原型与原型链","date":"2020-07-15T09:29:29.000Z","updated":"2021-03-08T09:43:24.542Z","comments":true,"path":"api/articles/简述Js中的原型与原型链.json","photos":[],"link":"","excerpt":null,"covers":["https://howlcn1997.github.io/2020/01/17/%E7%AE%80%E8%BF%B0Js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png","https://howlcn1997.github.io/2020/01/17/%E7%AE%80%E8%BF%B0Js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE.png"],"content":"<h2 id=\"1、原型\"><a href=\"#1、原型\" class=\"headerlink\" title=\"1、原型\"></a>1、原型</h2><p> Javascript是基于对象的编程语言，他其中也含有部分封装、继承的概念，而原型概念便是基于继承的。</p>\n<p> 函数的原型类似于面向对象语言中子类的父类，而函数本身类似于子类。函数继承了函数原型中的属性和方法，即函数本身可以调用它原型中的属性和方法。</p>\n<p> 知识点：若有函数Person，则它的函数原型为Person.prototype，函数原型本身是个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person (name) &#123;</span><br><span class=\"line\">  this.name &#x3D; name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.type &#x3D; &#39;human&#39;</span><br><span class=\"line\">Person.prototype.sayName &#x3D; function () &#123;</span><br><span class=\"line\">  console.log(this.name + &#39;说话了&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;此时我们用Person构造函数构造了一个p对象</span><br><span class=\"line\">var p &#x3D; new Person(&#39;小王&#39;);</span><br><span class=\"line\">&#x2F;&#x2F;我们打印p.name</span><br><span class=\"line\">console.log(p.name); &#x2F;&#x2F;结果是&#39;小王&#39;，因为Preson函数中已经预置了name属性并且接受了new对象时传入的&#39;小王&#39;，结果勿容置疑</span><br><span class=\"line\">&#x2F;&#x2F;我们再打印p.type 调用p.sayName()  按常理说Preson构造函数中是不存在type属性和sayName方法，若调用应该会报错</span><br><span class=\"line\">console.log(p.type); &#x2F;&#x2F;结果  human</span><br><span class=\"line\">p.sayName(); &#x2F;&#x2F; 结果  小王说话了</span><br><span class=\"line\">&#x2F;&#x2F;结果和我们预想的不同，这是为什么呢?</span><br><span class=\"line\">&#x2F;&#x2F;因为Person继承了它原型Person.prototype中的信息，当调用p.type时，会优先在Person类中找该属性，若找到了则直接使用，若没找到则在他的原型中找并使用。因为我们设置了Person原型的type属性的，则p可以直接使用</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中涉及到了 构造函数、对象和函数原型，接下来给出三者之间的关系图；</p>\n<h2 id=\"2、构造函数、实例、原型三者之间的关系\"><a href=\"#2、构造函数、实例、原型三者之间的关系\" class=\"headerlink\" title=\"2、构造函数、实例、原型三者之间的关系\"></a>2、构造函数、实例、原型三者之间的关系</h2><p><img src=\"https://howlcn1997.github.io/2020/01/17/%E7%AE%80%E8%BF%B0Js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png\" alt=\"三者关系\"></p>\n<p>由图中我们可以很直观的看到三者之间的关系。</p>\n<p>p对象由Person构造函数构造</p>\n<p>p对象通过__proto__属性访问到Person对象原型</p>\n<p>Person对象原型通过constructor访问Person构造函数</p>\n<p>Person函数通过prototype属性访问到Person原型对象</p>\n<p>注意：对象是通过__proto__属性访问对象原型，函数是通过prototype访问对象原型，但两者访问到的对象原型是同一个</p>\n<p>验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(p.__proto__ &#x3D;&#x3D; Person.prototype); &#x2F;&#x2F;结果为 true</span><br></pre></td></tr></table></figure>\n\n<p>constructor的作用：可以使得对象访问到对应的构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p &#x3D; new Person();</span><br><span class=\"line\">console.log(p.constructor);&#x2F;&#x2F; 打印  function Person()</span><br></pre></td></tr></table></figure>\n\n<p>知道以上的知识之后，我们还要了解，其实Person的原型也有原型，即存在Person.prototype.prototype，并且它是Person.prototype的原型，可以用图来直观了解这其中的关系，这便是一个简单的原型链。</p>\n<h2 id=\"3、原型链\"><a href=\"#3、原型链\" class=\"headerlink\" title=\"3、原型链\"></a>3、原型链</h2><p><img src=\"https://howlcn1997.github.io/2020/01/17/%E7%AE%80%E8%BF%B0Js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE.png\" alt=\"原型链\"></p>\n<h2 id=\"4、原型链中的搜索规则\"><a href=\"#4、原型链中的搜索规则\" class=\"headerlink\" title=\"4、原型链中的搜索规则\"></a>4、原型链中的搜索规则</h2><p>了解了 <strong>构造函数-实例-原型对象</strong> 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。</p>\n<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性</p>\n<ul>\n<li>搜索首先从对象实例本身开始</li>\n<li>如果在实例中找到了具有给定名字的属性，则返回该属性的值</li>\n<li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性</li>\n<li>如果在原型对象中找到了这个属性，则返回该属性的值</li>\n</ul>\n<p>也就是说，在我们调用 <code>p.sayName()</code> 的时候，会先后执行两次搜索：</p>\n<ul>\n<li>首先，解析器会问：“实例 p 有 sayName 属性吗？”答：“没有。</li>\n<li>”然后，它继续搜索，再问：“ p 的原型有 sayName 属性吗？”答：“有。</li>\n<li>”于是，它就读取那个保存在原型对象中的函数。</li>\n</ul>\n<p>而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>\n<p>总结：</p>\n<ul>\n<li>先在自己身上找，找到即返回</li>\n<li>自己身上找不到，则沿着原型链向上查找，找到即返回</li>\n<li>如果一直到原型链的末端还没有找到，则返回 <code>undefined</code></li>\n</ul>\n","categories":[],"tags":[]}