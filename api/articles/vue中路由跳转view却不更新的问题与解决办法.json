{"title":"vue中路由跳转view却不更新的问题与解决办法","slug":"vue中路由跳转view却不更新的问题与解决办法","date":"2020-11-23T09:45:38.000Z","updated":"2021-03-08T09:55:45.953Z","comments":true,"path":"api/articles/vue中路由跳转view却不更新的问题与解决办法.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h1 id=\"vue中路由跳转view却不更新的问题与解决办法\"><a href=\"#vue中路由跳转view却不更新的问题与解决办法\" class=\"headerlink\" title=\"vue中路由跳转view却不更新的问题与解决办法\"></a>vue中路由跳转view却不更新的问题与解决办法</h1><p>一般情况下路由从<code>/myrouter</code>跳转至<code>/yourrouter</code>时，view会发生更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若遇到&#x2F;products&#x2F;:id这样只改变id号的场景。就不会发生更新</span><br></pre></td></tr></table></figure>\n\n<p>情况如下：</p>\n<p><code>router.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path: &quot;&#x2F;products&#x2F;:id&quot;,</span><br><span class=\"line\">    name: &quot;product&quot;,</span><br><span class=\"line\">    components: Product</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在路由<code>/products/:id</code>对应一个组件<code>Product.vue</code>,组件中有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;test1&lt;&#x2F;h1&gt;</span><br><span class=\"line\">        &lt;p&gt;msg: &#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    mounted()&#123;</span><br><span class=\"line\">        this.init(this.$router.history.current.params.id);</span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    methods:&#123;</span><br><span class=\"line\">        init(id)&#123;</span><br><span class=\"line\">            this.msg &#x3D; this.$router.history.current.params.id;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>为什么上述情况会导致view不更新呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">答：由于router-view是复用的，单纯的改变id号并不会刷新router-view。追根揭底就是因为data没有变化，只要路由跳转时触发 init() 函数来改变data就可以了。</span><br></pre></td></tr></table></figure>\n\n<p>解决办法：</p>\n<ol>\n<li><p>用 :key 来阻止“复用”</p>\n<p>在父组件中使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-view :key&#x3D;&quot;key&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">\tkey() &#123;</span><br><span class=\"line\">\t\treturn this.$route.name !&#x3D;&#x3D; undefined? this.$route.name +new Date(): this.$route +new Date()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种办法实质上是让每次路由跳转时重新构建该组件，我们在它的生命周期中写一个打印语句就能看出来。</p>\n</li>\n<li><p>通过 watch 监听路由</p>\n<p>在子组件中使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123; &#x2F;&#x2F;通过watch来监听路由变化</span><br><span class=\"line\">    &#39;$route&#39;: function () &#123;</span><br><span class=\"line\">\t\tthis.init(this.$router.history.current.params.id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>通过 <code>vue-router</code>的钩子函数 <code>beforeRouteEnter</code> <code>beforeRouteUpdate</code> <code>beforeRouteLeave</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeRouteEnter (to, from, next) &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; 在渲染该组件的对应路由被 confirm 前调用</span><br><span class=\"line\">   &#x2F;&#x2F; 不！能！获取组件实例 &#96;this&#96;</span><br><span class=\"line\">   &#x2F;&#x2F; 因为当钩子执行前，组件实例还没被创建</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeRouteUpdate (to, from, next) &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; 在当前路由改变，但是该组件被复用时调用</span><br><span class=\"line\">   &#x2F;&#x2F; 举例来说，对于一个带有动态参数的路径 &#x2F;foo&#x2F;:id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，</span><br><span class=\"line\">   &#x2F;&#x2F; 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class=\"line\">   &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeRouteLeave (to, from, next) &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; 导航离开该组件的对应路由时调用</span><br><span class=\"line\">   &#x2F;&#x2F; 可以访问组件实例 &#96;this&#96;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":[],"tags":[]}